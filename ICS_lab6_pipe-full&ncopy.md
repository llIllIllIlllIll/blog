# A Summary on lab6 in ICS
这个lab相关的内容是一边修改一个y86-64 pipeline模拟器的hcl(pipe-full.hcl)一边去修改你手写的ncopy.ys(就是一个从一个地址复制n字节到另一个地址的函数)的汇编代码。
##
这个lab评分标准是你代码跑起来的CPE。10.5以上零分，7.5以下满分(60)，居于零分与满分之间的分数和你的CPE成线性关系。我做这个lab大概是第一天做到40分，第二天做到55分，最后做到58.9(CPE 7.56)这样子。进一步的优化我不太会弄，可能需要对hcl做更多的修改。这个blog主要记录和汇编代码有关的一些经验。
## pipe-full.hcl的修改
hcl修改的部分不多，按照书上的要求做了一个iaddq的实现，以及实现了解决load/use hazard的一个forwarding。这个不是最关键的部分，但是你必须做。
## ncopy.ys部分的修改
### 删除不必要的计算
因为这个函数必然是要写loop的，所以肯定要用到loop unrolling的技巧。然后受限于y86-64 16个寄存器，我的每个loop处理8个数。但是一开始我的代码结构大概是这个样子：
```c
int mod_of_n=n mod 8;//n为元素个数
if(mod_of_n==0)
{
    loop
}
else{
    deal with mod_of_n elements
    use a loop to deal with other elements
}
```
然后后来我发现这种取模的运算非常浪费，因为事实上取模写出来是这样子的：
```
irmovq 0x111,%rcx
andq %rdx,%rcx（这样子得到了%rdx的后三位，也就是mod8）
```
所以代码的结构其实可以换一换，我们也没有必要取模。改成这样子更好：
```c
// n为元素个数
n-=8;
if(n>=0)
{
    loop
}
else
{
    ...
}
```
这样子就是每次直接加减原数，不需要取模，代码结构会更适合运行。
### 对于极小的情况特殊处理
这个函数里，由于采用了每次8个元素的unrolling，循环内部是及其高效的。但是并不是每个数都可以被八整除，所以我们势必需要对1-7的值进行特殊的处理，否则这些比较小的数字就会限制我们的CPE。
##
我选择的办法是对于1-4的值手写传输函数。这样子可以解决1-7所有的情况。只要用1-3的值和4拼凑就可以了。
### 修改不必要的Jmp
这个的意思是，比如说原来的函数中你写出了Jmp Done这样子的语句，那么你要小心了。因为Done这个位置很可能就是一个ret。那么你Jmp Done 再ret是两条语句，但是如果你直接ret就只有一条语句，而且起的效果是一样的。
### 调整代码结构
这个和上面的内容其实是一个意思。有的时候你可以考虑把代码修改的不易阅读，但是可以省去一条类似于jmp这种没有条件的跳转指令。
## 以下内容更新于lab6的最后一天...
昨天凌晨一点我把CPE搞到了6.6，现在满分没有压力。这里用的技巧主要是去进一步修改了hcl，针对于按照andq->jle->iaddq这样的顺序进行了优化。当然这里其实也是利用了这个模拟器的一个bug，那就是这个模拟器内部不仅支持in和==这样子的逻辑判断，他居然还支持大于小于的判断...后面怎么做就不用说了。想看代码可以看这里。

[pipefull.hcl](blog/pipe-full.hcl)

<b>需要强调的是，我并不建议你使用这种方法...因为这只是一个bug，而且恰好是TA设置的测试条件没有测试这个问题。我做完也告诉YF助教了这个bug的存在......但我目测这个bug应该会一直存在下去。</b>